
# **技术架构文档 (详细版)：《轻盈》v1.5**

**日期：** 2025年10月26日
**架构师：** Gemini
**状态：** 最终方案 (可执行)

## 1\. 架构愿景与核心原则

(本节与高层概览一致，作为架构的“宪法”)

1.  **“轻盈” (Lightweight):** 性能是核心。应用加载必须快（\<2s），交互必须瞬时响应。
2.  **“触感” (Tactile):** 架构必须能完美支撑UI文档中定义的细腻、有弹性的物理动画。
3.  **“本地优先” (Local-First):** 核心用户数据（除AI功能外）必须保留在本地，以实现极致的性能、隐私保护 和核心功能的离线可用性。

## 2\. 核心架构模式：本地优先的CSR + BFF

我们采用**本地优先的客户端渲染 (CSR) + BFF (Backend-for-Frontend)** 混合架构。

  * **为什么是“本地优先”？**

      * **性能：** 关键数据（任务、日志）从本地IndexedDB读取，消除了网络延迟，这是实现“瞬时”交互和“\<2s加载” 的技术保障。
      * **隐私：** 满足NFR中的“用户日志加密存储，不上传云端” 的核心要求。
      * **体验：** 即使网络不稳定，用户依然可以访问和管理他们的“游玩手册”，这符合“非评判性”（即不会因网络差而惩罚用户）的理念。

  * **为什么是“CSR” (客户端渲染)？**

      * Next.js的核心优势是SSR/SSG，但这依赖于*服务端*的数据。我们的“唯一真实来源 (SSOT)”在*客户端* (IndexedDB)。
      * 因此，我们**刻意**将Next.js用作一个高性能的**SPA (单页应用) 启动器**。
      * **实现：** 在App Router的根`layout.js`或主`page.js`中声明`"use client;"`。Next.js将仅在服务端预渲染一个“静态壳”，所有的数据获取和交互逻辑都在客户端完成。

  * **为什么是“BFF”？**

      * **安全：** 这是唯一的目的。PRD要求调用智谱AI。我们**绝不能**将`ZHIPU_API_KEY`暴露在前端。BFF (即Next.js Route Handler) 是一个在服务端运行的“可信中间人”，它隐藏了密钥，并代理AI请求。

## 3\. 详细技术栈选型与理由

| 层面 | 技术选型 | 选用理由（详细） |
| :--- | :--- | :--- |
| **核心框架** | **Next.js (App Router)** | 虽然我们主要使用其CSR模式，但仍能获益于：1. 强大的**文件系统路由**；2. 高效的**代码分割**（每个页面只加载必要的JS）；3. 与Vercel部署平台的**无缝集成**；4. 团队**熟悉度**（这是关键的效率因素）。 |
| **组件样式** | **Styled Components** | **(关键决策)** 这是一个\*\*“雕琢”而非“搭建”**的项目。Tailwind的原子类无法高效实现UI文档中“有机”的非标准交互：<br> - 动态动画： 如“呼吸般”的聚焦光晕，需要自定义`@keyframes`。<br> - 伪元素交互： 如输入框“中心展开”的底线，需要复杂的`::after`和`:focus`组合。<br> - 状态驱动： Styled Components的`props`传参能以JS原生的方式优雅处理“真诚模式”的背景色渐变。 |
| 动画动效 | Framer Motion | (非可选项) React没有内置动画系统。为了实现“触感与真实”、“弹性曲线” 和“果冻效果”，基于物理的弹簧(Spring)动画库是必需的。Framer Motion是React生态首选，与Styled Components兼容性良好。 |
| 本地数据库 | Dexie.js (IndexedDB) | IndexedDB是浏览器唯一的持久化、大容量存储方案。原生API是回调地狱。Dexie.js提供了现代的、基于Promise的API，并内置了`useLiveQuery`钩子，是实现**响应式数据流\*\*的基石。 |
| **客户端状态** | **Zustand** | 我们需要一个全局状态来存放从Dexie.js订阅来的数据。**为什么不用Context API？** Context在数据频繁变化时（如用户在`PlaybookPage` 快速筛选）会导致全树重绘，性能低下。Zustand是轻量级的（\<1KB），通过选择器(selectors)实现精细化订阅，避免了不必要的重绘，完美符合“轻盈” 原则。 |
| **BFF (AI 代理)** | **Next.js Route Handlers** | 内置于Next.js，零配置。Vercel会自动将其部署为Serverless Function，无需额外管理服务器。 |
| **部署平台** | **Vercel** | Next.js的母公司，提供全球CDN（用于静态壳）和边缘函数（用于BFF），是实现高性能和低延迟AI请求的最佳组合。 |

## 4\. 数据架构 (Data Layer)

### 4.1 Schema 详解

数据库`LightnessAppDB`中的`experiences`表是**唯一的数据来源**。

```javascript
// /lib/db.js
import Dexie from 'dexie';

export const db = new Dexie('LightnessAppDB');
db.version(1).stores({
  experiences: [
    '++id',         // 主键
    'status',       // 索引, 核心状态机: 'undesigned', 'designed', 'logged'
    'createdAt',    // 索引, 用于“游乐场” 默认排序
    'design.persona', // 索引, 用于“手册” 按人格筛选
    'log.feeling'   // 索引, 用于“手册” 按情绪筛选
    // PRD中“任务类型” 筛选因V1.2无此输入而搁置
  ].join(',')
});
```

### 4.2 数据模型演化 (State Machine)

一个`experience`文档的生命周期：

1.  **创建 (in `PlaygroundPage`)**:

      * `db.experiences.add({ title: "...", status: "undesigned", createdAt: new Date() })`
      * *JSON (部分)*: `{ "id": 1, "title": "打扫公寓", "status": "undesigned", "design": null, "log": null }`

2.  **设计 (in `WizardPage`)**:

      * `db.experiences.update(1, { status: "designed", design: { persona: "...", sideQuest: "..." } })`
      * *JSON (部分)*: `{ "status": "designed", "design": { "persona": "探索者", ... }, "log": null }`

3.  **记录 (in `LogPage`)**:

      * `db.experiences.update(1, { status: "logged", log: { feeling: "...", insight: "..." } })`
      * *JSON (完整)*: `{ "status": "logged", "design": {...}, "log": { "feeling": "放松愉快", ... } }`

### 4.3 核心查询模式 (Query Patterns)

  * **游乐场 - 待设计**: `db.experiences.where('status').equals('undesigned').sortBy('createdAt')`
  * **游乐场 - 今日游玩**: `db.experiences.where('status').equals('designed').sortBy('createdAt')`
  * **游玩手册 - 全量**: `db.experiences.where('status').equals('logged').reverse().sortBy('log.loggedAt')`
  * **游玩手册 - 筛选**: `db.experiences.where({ status: 'logged', 'design.persona': '探索者' })...`

## 5\. 视图与组件架构 (View Layer)

### 5.1 组件通信

  * **页面间通信：** 通过**路由参数**。例如，`PlaygroundPage`中的卡片点击后，通过`router.push('/design/[id]')`导航，将`id`传递给`WizardPage`。
  * **全局状态通信：** 通过**Zustand**。组件（如`PlaygroundPage`）从`useExperienceStore`获取任务列表，而数据更新的触发（如`LogPage`中的`db.experiences.update`）会自动通过`useLiveQuery`更新Store，实现响应式。

### 5.2 原子组件实现（示例）

以`<Input />`为例，展示如何实现“触感”：

  * **文件**: `/components/atoms/Input.js`
  * **技术**: `styled-components`, `React.forwardRef`
  * **实现**:
      * 使用`styled.input`。
      * **底线动画**: 使用`::after`伪元素，`transform-origin: center`，默认`transform: scaleX(0)`。在`:focus-within`（包裹器）或`:focus`（输入框）时，`transform: scaleX(1)`，并配合`transition`。
      * **光标动画**: 使用`caret-color: #4A443F` 覆盖默认颜色。使用`@keyframes`自定义一个`opacity`从0到1再到0的“呼吸”动画，并应用到`animation`属性上，替代浏览器的“硬闪”。
      * **标签浮动**: 提示文字（Placeholder）将通过一个`styled.label`实现，根据输入框的`:focus`或`value`（非空）状态，通过`transform: translateY()`向上移动。

## 6\. 数据流（核心）

这是本架构最关键的部分，它连接了“本地数据”和“React视图”。

### 6.1 流程图 (ASCII)

```
[React Components]          (Zustand)            (Dexie.js)
  (e.g., LogPage)         <useExperienceStore>   <Dexie Hooks>      [IndexedDB]
       |                         ^                     ^                 ^
       | -- 1. 写入 (Write) ---> |                     | -- 2. 触发 ----> |
       |    (db.experiences.update)                    |    (Change)        |
       |                         |                     |                 |
(e.g., PlaybookPage)             |                     |                 |
       |                         |                     |                 |
       | <-- 5. 订阅 (Read) --- | -- 4. 更新(Update) -- | -- 3. 订阅(Notify) |
       |     (useStore)           |     (setState)      |    (useLiveQuery)  |
```

### 6.2 详细流程

1.  **写入 (Write)**: `LogPage` 调用`await db.experiences.update(id, ...)`。
2.  **触发 (Trigger)**: Dexie.js内部机制检测到`experiences`表发生变更。
3.  **订阅 (Notify)**: 在根`layout.js`中，一个常驻的`<DataSubscriber />`组件内的`useLiveQuery(() => db.experiences.where('status').equals('logged')...)`钩子被自动触发。
4.  **更新 (Update)**: `useLiveQuery`返回了最新的“已记录”任务数组。`useEffect`钩子被触发，调用`useExperienceStore.setState({ loggedTasks: ... })`，将新数据更新到Zustand。
5.  **读取 (Read)**: `PlaybookPage` 组件通过`const { loggedTasks } = useExperienceStore()`订阅了`loggedTasks`。Zustand检测到`loggedTasks`变化，仅重绘`PlaybookPage`组件，UI自动更新。

**结果**：数据流是**完全被动和响应式**的。组件只负责“写入”和“读取”，无需管理加载、错误或手动刷新状态。

## 7\. BFF 与 AI 交互

### 7.1 安全模型

  * **密钥保护**: `ZHIPU_API_KEY` 存储在Vercel的**环境变量**中，仅BFF (服务器端) 可通过`process.env`访问。
  * **CORS 策略**: BFF端点将配置CORS，**仅允许**来自我们生产域名的请求。
  * **速率限制 (可选)**: 可在BFF中添加基于IP的速率限制，防止API被恶意刷量。

### 7.2 提示词工程 (Prompt Engineering)

BFF将负责构建提示词，而非客户端，以确保一致性和安全。

  * **BFF 端点**: `POST /api/get-suggestion` (Next.js Route Handler)
  * **服务端逻辑**:
    ```javascript
    // /app/api/get-suggestion/route.js
    const task = request.json().title;
    const persona = request.json().persona;

    // PRD驱动的提示词
    const prompt = `你是一个“过程体验设计器”。任务是"${task}"，人格是"${persona}"。请推荐一个简短、有趣、充满好奇心的“支线任务”（Side Quest）。比如“打扫公寓”+“探索者” -> “寻找一个被你遗忘超过半年的物品”。请直接返回支线任务，不要多余的话。`;

    // ... 调用智谱AI API ...
    ```

### 7.3 核心：非评判性错误处理

这是产品灵魂的体现。

  * **BFF (try...catch)**:
      * `try`: 成功调用AI -\> `return NextResponse.json({ success: true, suggestion: "..." })`
      * `catch (error)`: AI超时、API密钥错误、网络失败 -\> `return NextResponse.json({ success: false, suggestion: null })`
  * **客户端 (UI)**:
      * `WizardPage` 收到`{ success: false }`。
      * **禁止**：显示`Alert("AI失败，请重试")`或红色错误文本（违反“非评判性”）。
      * **执行**：**静默地、无缝地**回退到“写下自己的想法” 的输入框，并自动`focus()`该输入框。
      * **效果**：用户感觉AI（B计划）失败了，但产品（A计划）无缝接管，体验没有中断或压力。

## 8\. 部署与构建 (Vercel)

  * **构建流程 (`next build`)**: Vercel将：
    1.  构建Next.js应用。
    2.  将`"use client;"`的页面打包为JS Chunks。
    3.  将应用的“静态壳”（HTML/CSS）部署到全球CDN。
    4.  将`/api/get-suggestion`部署为边缘函数 (Edge Function)。
  * **CI/CD**:
      * Push到`main`分支 -\> 自动触发生产部署。
      * Push到`feature/*`分支 -\> 自动生成**预览(Preview)部署**。这对于PM和设计师在合并前验证PRD 和UI 的实现至关重要。
